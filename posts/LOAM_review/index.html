<!DOCTYPE html><html lang="ko" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="[LOAM] LOAM: Lidar Odometry and Mapping in Real-time 논문 리뷰" /><meta property="og:locale" content="ko" /><meta name="description" content="3학년 여름방학동안 김아영 교수님 연구실에서 UROP(Undergraduate Research Opportunity Program) 연구를 수행하였다. 연구 과제는 “4족 보행 로봇 Spot을 위한 HW/SW 시스템 구축”으로, Spot에 탑재할 센서 시스템(LiDAR, IMU, GNSS, Camera) 하드웨어를 설계하고 SLAM 알고리즘을 돌려보는 활동으로 구성되었다. 본 포스팅부터는 여름방학동안 학습한 SLAM 논문을 리뷰하고 Spot으로 실제 측정한 데이터를 바탕으로 SLAM을 돌려보는 과정을 정리해보고자 한다." /><meta property="og:description" content="3학년 여름방학동안 김아영 교수님 연구실에서 UROP(Undergraduate Research Opportunity Program) 연구를 수행하였다. 연구 과제는 “4족 보행 로봇 Spot을 위한 HW/SW 시스템 구축”으로, Spot에 탑재할 센서 시스템(LiDAR, IMU, GNSS, Camera) 하드웨어를 설계하고 SLAM 알고리즘을 돌려보는 활동으로 구성되었다. 본 포스팅부터는 여름방학동안 학습한 SLAM 논문을 리뷰하고 Spot으로 실제 측정한 데이터를 바탕으로 SLAM을 돌려보는 과정을 정리해보고자 한다." /><link rel="canonical" href="https://isornorphism.github.io/posts/LOAM_review/" /><meta property="og:url" content="https://isornorphism.github.io/posts/LOAM_review/" /><meta property="og:site_name" content="Isomorphism!" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-09-10T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[LOAM] LOAM: Lidar Odometry and Mapping in Real-time 논문 리뷰" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-09-10T00:00:00+09:00","datePublished":"2022-09-10T00:00:00+09:00","description":"3학년 여름방학동안 김아영 교수님 연구실에서 UROP(Undergraduate Research Opportunity Program) 연구를 수행하였다. 연구 과제는 “4족 보행 로봇 Spot을 위한 HW/SW 시스템 구축”으로, Spot에 탑재할 센서 시스템(LiDAR, IMU, GNSS, Camera) 하드웨어를 설계하고 SLAM 알고리즘을 돌려보는 활동으로 구성되었다. 본 포스팅부터는 여름방학동안 학습한 SLAM 논문을 리뷰하고 Spot으로 실제 측정한 데이터를 바탕으로 SLAM을 돌려보는 과정을 정리해보고자 한다.","headline":"[LOAM] LOAM: Lidar Odometry and Mapping in Real-time 논문 리뷰","mainEntityOfPage":{"@type":"WebPage","@id":"https://isornorphism.github.io/posts/LOAM_review/"},"url":"https://isornorphism.github.io/posts/LOAM_review/"}</script><title>[LOAM] LOAM: Lidar Odometry and Mapping in Real-time 논문 리뷰 | Isomorphism!</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Isomorphism!"><meta name="application-name" content="Isomorphism!"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/profile.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Isomorphism!</a></div><div class="site-subtitle" style="letter-spacing: -0.02em;">다채로운 vectorspace를 span할 수 있도록<br> orthogonal basis를 만드는 곳입니다.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/CV/" class="nav-link"> <i class="fa-fw fas fa-file ml-xl-3 mr-xl-3 unloaded"></i> <span>CV</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Isornorphism" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sgheong','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[LOAM] LOAM: Lidar Odometry and Mapping in Real-time 논문 리뷰</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[LOAM] LOAM: Lidar Odometry and Mapping in Real-time 논문 리뷰</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/Isornorphism">Gwanhyeong Song</a> </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" date="2022-09-10 00:00:00 +0900" data-toggle="tooltip" data-placement="bottom" title="Sat, Sep 10, 2022, 12:00 AM +0900" >Sep 10, 2022</em> </span> <span> Updated <em class="timeago" date="2022-09-10" data-toggle="tooltip" data-placement="bottom" title="Sat, Sep 10, 2022, 12:00 AM +0000" >Sep 10, 2022</em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2739 words"> <em>15 min</em> read</span></div></div></div><div class="post-content"><p>3학년 여름방학동안 김아영 교수님 연구실에서 UROP(Undergraduate Research Opportunity Program) 연구를 수행하였다. 연구 과제는 <em>“4족 보행 로봇 Spot을 위한 HW/SW 시스템 구축”</em>으로, Spot에 탑재할 센서 시스템(LiDAR, IMU, GNSS, Camera) 하드웨어를 설계하고 SLAM 알고리즘을 돌려보는 활동으로 구성되었다. 본 포스팅부터는 여름방학동안 학습한 SLAM 논문을 리뷰하고 Spot으로 실제 측정한 데이터를 바탕으로 SLAM을 돌려보는 과정을 정리해보고자 한다.</p><blockquote><p><em>Original paper</em></p><ul><li><a href="https://www.ri.cmu.edu/pub_files/2014/7/Ji_LidarMapping_RSS2014_v8.pdf">LOAM: Lidar Odometry and Mapping in Real-time</a></ul></blockquote><blockquote><p><em>다음 자료를 참고하였습니다.</em></p><ul><li><a href="https://dreambreaker-ds.tistory.com/entry/LOAM-Lego-LOAM">LOAM, Lego-LOAM</a><li><a href="https://alida.tistory.com/44">[SLAM] Lidar Odometry And Mapping (LOAM) 논문 리뷰</a><li><a href="https://www.youtube.com/watch?v=snPzNmcbCCQ">SLAM 온라인 스터디 SLAM DUNK 2020 | 정진용님 발표</a><li><a href="https://limhyungtae.github.io/2022-03-27-LeGO-LOAM-Line-by-Line-1.-Introduction/">LeGO-LOAM Line by Line</a></ul></blockquote><p><br /></p><h2 id="1-introduction">1. Introduction <a href="#1-introduction" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>LOAM은 논문 제목에서 알 수 있듯이 LiDAR 센서만을 이용하여 odometry와 mapping을 실시간으로 수행하는 SLAM이다. 기존 SLAM 경우 off-line, 즉 데이터 수집 후 프로그램을 돌리는 방식으로 3D mapping을 수행하였고, drift를 보정하기 위해 loop closure를 사용하였다. 그러나 LOAM은 계산 복잡도를 줄여 실시간 SLAM이 가능하도록 하였는데, 이는 전체 알고리즘을 odometry를 계산하는 블록과 mapping 블록으로 나누어 병렬적으로 처리하였기 때문에 가능하였다.</p><blockquote><p><strong>[Note]</strong> Terminology</p></blockquote><blockquote><p><strong>SLAM</strong> : Simultaneous Localization and Mapping의 약자이다. 로봇이 주변 환경을 센서로 감지하여 주변 map을 제작하고, map 내에 현재 자신의 위치를 추정하는 작업을 동시에 진행하는 기술이다.</p></blockquote><blockquote><p><strong>LiDAR</strong> : 레이저 센서가 360도 회전(sweep)하면서 주위 환경을 스캔하는 장치이다. 다른 센서와 비교하여 상당한 거리 정밀도를 보이고, 주변 조명과 재질에 둔감하다는 장점이 있다. 센서가 움직이면서 mapping하는 경우 LiDAR의 위치를 계속 추정하는 작업이 필요하다.</p></blockquote><blockquote><p><strong>Odometry</strong> : 로봇이 주행한 궤적을 의미한다. IMU나 wheel encoder를 이용하여 odometry를 추정할 경우 센서 데이터를 계속 적분하게 되므로 시간에 따라 오차가 누적된다. 따라서 궤적이 전체적으로 틀어지는 drift 문제가 발생할 수 있다. 이를 해결하고자 로봇이 이전에 방문했던 위치에 되돌아왔는지 판단하는 loop closure detection을 도입하기도 한다. 본 논문은 loop closure를 포함하지 않고 SLAM 문제를 해결하였다.</p></blockquote><p><br /></p><h2 id="2-notation">2. Notation <a href="#2-notation" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>Right subcription $k$ : # of Sweeps<li>$\mathcal{P}_k$ : k번째 sweep으로 얻어진 pointclound 데이터<li>$\{ L \}$ : LiDAR coordinate system<li>$\{ W \}$ : World coordinate system<li>$X_{(k,i)}^{L}$ : LiDAR coordinate system에서 k번째 sweep으로 얻은 i번째 점<li>$X_{(k,i)}^{W}$ : World coordinate system에서 k번째 sweep으로 얻은 i번째 점</ul><p><br /></p><h2 id="3-system-block-diagram">3. System Block Diagram <a href="#3-system-block-diagram" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p><img data-src="/assets/img/LOAM_review/block_diagram.png" alt="system_block_diagram" width="90%" data-proofer-ignore> <em>출처: 원 논문</em></p><ul><li><strong>LiDAR Odometry</strong> : 2개의 연속적인 sweeps을 바탕으로 상대 운동을 계산하는 노드, 10Hz로 수행<li><strong>LiDAR Mapping</strong> : Odometry를 바탕으로 pointcloud를 world coordinate system으로 매칭하는 노드, 1Hz로 수행<li><strong>Transform Integration</strong> : Odometry와 mapping을 바탕으로 현재 로봇의 transform을 계산하는 노드</ul><p><br /></p><h2 id="4-lidar-odometry">4. LiDAR Odometry <a href="#4-lidar-odometry" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>크게</p><ul><li><strong>Feature Point Estimation</strong><li><strong>Finding Feature Point Correspondence</strong><li><strong>Motion Estimation</strong></ul><p>3 단계로 구성된다.</p><p><br /></p><h3 id="41-feature-point-estimation">4.1 Feature Point Estimation <a href="#41-feature-point-estimation" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>$i \in \mathcal{P}_k$인 한 점 $i$에 대해 $i$ 점과 horizontal하게 인접해있는 점들의 집합을 $\mathcal{S}$라고 정의한다. 구현된 코드 상에서는 양쪽 5개씩 총 10개의 점을 사용하였다. 이때 local surface의 curvature $c$를 다음과 같이 나타낼 수 있다.</p>\[c = \frac{1}{|\mathcal{S}| \cdot \| X_{(k,i)}^{L} \| } \| \sum_{j \in \mathcal{S}, j \neq i} ( X_{(k,i)}^{L} - X_{(k,j)}^{L} ) \|\]<p><img data-src="/assets/img/LOAM_review/edge_planar.png" alt="edge_planar_feature" width="80%" data-proofer-ignore> <em>출처: <a href="https://limhyungtae.github.io/2022-03-27-LeGO-LOAM-Line-by-Line-3.-FeatureAssociation-(1)/">LeGO-LOAM Line by Line - 3. FeatureAssociation (1)</a></em></p><p>식의 의미를 그림으로 해석해보자. Local surface가 planar한 경우 점들의 depth가 등차수열을 이루므로 $\sum_{j \in \mathcal{S}, j \neq i} ( X_{(k,i)}^{L} - X_{(k,j)}^{L} )$ 값이 양쪽에서 서로 상쇄되어 0에 가까운 값이 나올 것이다. 반면 local surface가 edge와 같이 뾰족할 경우 $\sum_{j \in \mathcal{S}, j \neq i} ( X_{(k,i)}^{L} - X_{(k,j)}^{L} )$ 값이 크게 나올 것이다. 즉, $c$ 값이 작은 경우 planar feature($\mathcal{H}_k$)에 해당하고, 큰 경우 edge feature($\mathcal{E}_k$)에 해당한다.</p><p>논문에서는 1 sweep으로 얻은 데이터를 4개의 sub-region으로 나눈 후 각 sub-region에서 최대 2개의 edge points와 4개의 planar points를 사용하였다고 밝혔다. Edge points와 planar points는 $c$ 값이 특정 threshold보다 크거나 작을 경우에 해당한다.</p><p><img data-src="/assets/img/LOAM_review/outlier.png" alt="outlier_case" width="80%" data-proofer-ignore> <em>출처: 원 논문</em></p><p>다음 상황과 같이 (a) local surface가 laser 방향과 거의 평행한 경우는 $c$를 계산할 때 정확도가 떨어진다. (b) 차폐로 인해 edge points로 오인된 경우 보는 각도에 따라 다른 feature로 인식될 수 있다. 따라서 두 경우를 outlier로 간주하여 제외한다.</p><blockquote><p><strong>[Note]</strong> 구현 상 오류(?)</p></blockquote><p><img data-src="/assets/img/LOAM_review/pixel_error.PNG" alt="implementation_error" width="90%" data-proofer-ignore> <em>출처: <a href="https://limhyungtae.github.io/2022-03-27-LeGO-LOAM-Line-by-Line-3.-FeatureAssociation-(1)/">LeGO-LOAM Line by Line - 3. FeatureAssociation (1)</a></em></p><blockquote><p>실제로 구현 코드에서는 valid pixel만을 사용하기 때문에 $X_{(k,j)}^{L} (j \in \mathcal{S})$가 일정한 간격의 horizontal한 점들로 구성되지 않을 수 있다는 오류가 있다고 한다. 그림과 같이 $X_{(k,i+5)}^{L}$가 다음 줄로 넘어가는 경우 엉뚱한 $c$ 값이 도출된다.</p></blockquote><p><br /></p><h3 id="42-finding-feature-point-correspondence">4.2 Finding Feature Point Correspondence <a href="#42-finding-feature-point-correspondence" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>LiDAR odometry의 목적은</p>\[T_{k+1}^L = [ t_x, t_y, t_z, {\theta} _{x}, {\theta} _{y}, {\theta} _{z} ]\]<p>즉, $t_{k+1}$ 시점에서 로봇의 pose를 계산하는 것이다. 이때 $t$는 평행운동 성분, ${\theta}$는 회전운동 성분이다. 우선 sweep이 시작하기 전 $T_{k+1}^L$ 값을 초기화해준다. 논문에서는 $T_{k+1}^L = 0$으로 초기화하였으나, IMU가 있을 경우 IMU에서 측정한 속도 값으로 초기화할 수 있다.</p><p>로봇이 움직이면서 laser scan이 진행되므로 한 sweep에서 측정한 pointcloud이더라도 좌표계가 바뀔 수 있다. 따라서 점들을 기준 시점에서 측정했을 때의 좌표로 transform하는 작업이 필요한데, 이를 <strong>de-skewing</strong>이라고 한다.</p><p><img data-src="/assets/img/LOAM_review/time_diagram.png" alt="time_diagram" width="60%" data-proofer-ignore> <em>출처: 원 논문</em></p><p>$t \in [t_{k+1}, t_{k+2}]$일 때, 즉 k+1번째 sweep을 수행중일 때를 보자. $P_{k}$는 완전히 갖고 있고, $P_{k+1}$은 그림과 같이 누적되고 있는 상태이다. 우리의 목표는 $t_{k+1}$ 시점에서 $P_{k}$와 $P_{k+1}$의 대응점을 탐색하는 것이다. 이를 위해서는 앞서 초기화한 $T_{k+1}^L$을 이용할 수 있다. 예를 들어 $P_{k} \rightarrow \bar{P_{k}}$로 transform할 때에는</p>\[\bar{ X}_{(k,i)}^L = R X_{(k,i)}^L + T_{(k+1,i)}^L [1:3] \Delta t\]<p>변환 공식을 이용한다. 이때 $\Delta t$는 특정 좌표의 점을 scan했을 때 시점과 기준 시점($t_{k+1}$)과의 차이고,</p>\[R = e^{\hat{\omega} \theta}\] \[\hat{\omega}= \textrm{Skew matrix of } \:\: T_{(k+1,i)}^L [4:6] \Delta t\] \[\theta = \textrm{Rotation angle}\]<p>로 정의된다. 마찬가지로 $P_{k+1}$에서 $t$까지 측정한 점들을 transform하여 $\tilde{P}_{k+1}$을 얻는다.</p><p>다음으로 edge feature, planar feature 각각에서 $\bar{P} _ {k}$, $\tilde{P} _ {k+1}$ 사이의 대응점을 탐색한다.</p><h4 id="421-edge-feature">4.2.1 Edge feature <a href="#421-edge-feature" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>기본적인 아이디어는 외적을 이용하여 점과 직선 사이를 계산하는 것이다.</p><ol><li>$i \in \tilde{\mathcal{E}}_{k+1}$인 edge point를 선택한다<li>$i$와 가깝고 연속적으로 위치한 $j, l \in \bar{P}_{k}$를 구한다.<li>Curvature $c$를 계산하여 $(j, l)$이 edge feature임이 확인된 경우</ol>\[d_{\mathcal{E}}=\frac{|(\tilde{X}_{(k+1,i)}^L - \bar{X}_{(k,j)}^L)\times(\tilde{X}_{(k+1,i)}^L - \bar{X}_{(k,l)}^L)|}{|\bar{X}_{(k,j)}^L - \bar{X}_{(k,l)}^L|}\]<p>을 계산하여 edge feature에서의 거리 함수를 계산할 수 있다.</p><h4 id="422-planar-feature">4.2.2 Planar feature <a href="#422-planar-feature" class="anchor"><i class="fas fa-hashtag"></i></a></h4></h4><p>기본적인 아이디어는 외적을 이용하여 점과 평면 사이를 계산하는 것이다.</p><ol><li>$i \in \tilde{\mathcal{H}}_{k+1}$인 edge point를 선택한다<li>$i$와 가깝고 연속적으로 위치한 $j, l, m \in \bar{P}_{k}$를 구한다.<li>Curvature $c$를 계산하여 $(j, l, m)$이 planar feature임이 확인된 경우</ol>\[d_{\mathcal{H}}=\frac{ \begin{vmatrix} (\tilde{X}_{(k+1,i)}^L - \bar{X}_{(k,j)}^L) \\ (\bar{X}_{(k,j)}^L - \bar{X}_{(k,l)}^L)\times(\bar{X}_{(k,j)}^L - \bar{X}_{(k,m)}^L) \end{vmatrix}} {|(\bar{X}_{(k,j)}^L - \bar{X}_{(k,l)}^L)\times(\bar{X}_{(k,j)}^L - \bar{X}_{(k,m)}^L)|}\]<p>을 계산하여 planar feature에서의 거리 함수를 계산할 수 있다.</p><p><br /></p><h3 id="43-motion-estimation">4.3 Motion Estimation <a href="#43-motion-estimation" class="anchor"><i class="fas fa-hashtag"></i></a></h3></h3><p>Edge, planar feature에서 도출한 거리 함수를 최소화하는 방향으로 $T_{k+1}^L$를 optimize해야 한다. 즉,</p>\[\textrm{Goal} : \underset{T_{k+1}^L}{\operatorname{argmin}} {\| \textbf{d}\|} \;\; \textrm{where} \;\; \textbf{d} = \begin{bmatrix} d_{\mathcal{E}} \\ d_{\mathcal{H}} \end{bmatrix} = \begin{bmatrix} f_{\mathcal{E}}(X_{(k+1,i)}^L, T_{k+1}^L) \\ f_{\mathcal{H}}(X_{(k+1,i)}^L, T_{k+1}^L) \end{bmatrix}\]<p>로 정리할 수 있다. 본 논문에서는 <strong>Levenberg-Marquardt</strong> 알고리즘을 사용하여 optimization을 수행한다고 밝혔다.</p>\[T_{k+1}^L \leftarrow T_{k+1}^L - (J^{T}J + \lambda \cdot \textrm{diag}(J^{T}J))^{-1} J^{T} \textbf{d}(T_{k+1}^L)\]<p>이를 위해서는 $\textbf{d}$의 Jacobian matrix가 필요하다. 구현 코드를 보면 직접 수식을 전개하여 계산한 것으로 보인다.</p><p><br /></p><blockquote><p><strong>[Note]</strong> Levenberg-Marquardt method<br /> Gradient descent method와 Gauss-Newton method을 결합한 방법이다. 해에서 멀리 떨어져 있을 때에는 Gradient descent method가 우세하여 빠르게 해에 수렴하고, 해 근처에 있을 때에는 Gauss-Newton method가 우세하게 작동한다. Gauss-Newton method보다 안정적으로 해를 탐색할 수 있고, 빠르게 해에 수렴한다는 장점이 있다.</p></blockquote><blockquote><p><strong>Gradient descent method</strong></p></blockquote>\[x_{k+1} = x_{k} - \alpha J^{T} f(x_{k})\]<blockquote><p><strong>Gauss-Newton method</strong></p></blockquote>\[x_{k+1} = x_{k} - \textrm{pinv}(J) f(x_{k}) = x_{k} - (J^{T}J)^{-1}J^{T} f(x_{k})\]<blockquote><p><strong>Levenberg-Marquardt method</strong></p></blockquote>\[x_{k+1} = x_{k} - (J^{T}J + \alpha \cdot \textrm{diag}(J^{T}J))^{-1} J^{T} f(x_{k})\]<p><br /></p><h2 id="5-lidar-mapping">5. LiDAR Mapping <a href="#5-lidar-mapping" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>LiDAR Odometry와 달리 LiDAR Mapping은 sweep이 마무리될 때마다 수행된다. LiDAR Odometry 단계에서 계산한 de-skewing된 $\bar{P} _ {k+1}$를 $\{W\}$에 registration한다.</p><p>$k$번째 sweep이 끝난 후 world map에 registration된 pointcloud를 $Q_{k}$이라 하고, $T_{k+1}^{W}$에 의해 transform된 $\bar{P} _ {k+1}$를 $\bar{Q} _ {k+1}$라고 하자. 이때 우리의 목표는 LiDAR Odometry 과정과 유사하게 $T_{k+1}^{W}$를 최적화하여 적절한 $\bar{Q}_{k+1}$를 구하는 것이다.</p><p>LiDAR Odometry 단계와 마찬가지로 feature extraction, finding feature point correspondence, motion estimation 과정을 거쳐 $\bar{Q}_{k+1}$를 계산한다. 몇 가지 차이점은 아래에 정리하였다.</p><ul><li>LiDAR Mapping은 LiDAR Odometry보다 더 작은 주기로 수행되므로(10Hz vs 1Hz) 10배 많은 point를 사용한다. 따라서 10배 많은 edge, planar feature를 사용한다.<li>Edge, planar feature를 판별할 때 feature point 주변의 point $\mathcal{S’}$에 대하여 <strong>eigen decomposition</strong>을 수행한다. 3개의 eigenvalue ${\lambda} _ {1} &gt; {\lambda} _ {2} &gt; {\lambda} _ {3}$에 대해</ul>\[{\lambda} _ {1} \gg {\lambda} _ {2} &gt; {\lambda} _ {3}\]<p>이면 edge feature,</p>\[{\lambda} _ {1} &gt; {\lambda} _ {2} \gg {\lambda} _ {3}\]<p>이면 planar feature로 분류한다.</p><p><br /></p><h2 id="6-transform-integration">6. Transform Integration <a href="#6-transform-integration" class="anchor"><i class="fas fa-hashtag"></i></a></h2></h2><p>최종적으로 LiDAR의 pose는 sweep 당 1번씩(1Hz) $T_{k+1}^{W}$을 사용하여 update하고, 10Hz마다 $T_{k+1}^{L}$을 사용하여 update한다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/slam/'>SLAM</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/loam/" class="post-tag no-text-decoration" >loam</a> <a href="/tags/lidar/" class="post-tag no-text-decoration" >lidar</a> <a href="/tags/odometry/" class="post-tag no-text-decoration" >odometry</a> <a href="/tags/mapping/" class="post-tag no-text-decoration" >mapping</a> <a href="/tags/levenberg/" class="post-tag no-text-decoration" >Levenberg</a> <a href="/tags/marquardt/" class="post-tag no-text-decoration" >Marquardt</a> <a href="/tags/lm/" class="post-tag no-text-decoration" >LM</a> <a href="/tags/edge/" class="post-tag no-text-decoration" >edge</a> <a href="/tags/planar/" class="post-tag no-text-decoration" >planar</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[LOAM] LOAM: Lidar Odometry and Mapping in Real-time 논문 리뷰 - Isomorphism!&url=https://isornorphism.github.io/posts/LOAM_review/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[LOAM] LOAM: Lidar Odometry and Mapping in Real-time 논문 리뷰 - Isomorphism!&u=https://isornorphism.github.io/posts/LOAM_review/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://isornorphism.github.io/posts/LOAM_review/&text=[LOAM] LOAM: Lidar Odometry and Mapping in Real-time 논문 리뷰 - Isomorphism!" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/IR_light_2/">[IR light] 전등 리모컨 제작기 - 2</a><li><a href="/posts/IR_light_3/">[IR light] 전등 리모컨 제작기 - 3</a><li><a href="/posts/IR_light_1/">[IR light] 전등 리모컨 제작기 - 1</a><li><a href="/posts/3D_scanner_4/">[3D scanner] 3D scanner 제작기 - 4</a><li><a href="/posts/3D_scanner_3/">[3D scanner] 3D scanner 제작기 - 3</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/3d-scanner/">3D scanner</a> <a class="post-tag" href="/tags/ir-light/">IR light</a> <a class="post-tag" href="/tags/solidworks/">Solidworks</a> <a class="post-tag" href="/tags/discriminator/">discriminator</a> <a class="post-tag" href="/tags/exponential/">exponential</a> <a class="post-tag" href="/tags/gan/">gan</a> <a class="post-tag" href="/tags/generative-model/">generative model</a> <a class="post-tag" href="/tags/generator/">generator</a> <a class="post-tag" href="/tags/hardware/">hardware</a> <a class="post-tag" href="/tags/levenberg/">Levenberg</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/LeGO_LOAM_review/"><div class="card-body"> <em class="timeago small" date="2022-09-13 00:00:00 +0900" >Sep 13, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[LeGO-LOAM] LeGO-LOAM: Lightweight and Ground-Optimized Lidar Odometry and Mapping on Variable Terrain 논문 리뷰</h3><div class="text-muted small"><p> LeGO-LOAM은 ground를 이용하여 LOAM 알고리즘을 경량화하고 성능과 속도를 향상시켰다. LOAM과 비교하여 개선된 점을 위주로 논문을 정리해보았다. Original paper LeGO-LOAM: Lightweight and Ground-Optimized Lidar Odometry and Mapping on Variabl...</p></div></div></a></div><div class="card"> <a href="/posts/SO3_group/"><div class="card-body"> <em class="timeago small" date="2022-09-15 00:00:00 +0900" >Sep 15, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Lie group] SO(3) group 정리</h3><div class="text-muted small"><p> LIO-SAM 논문 리딩을 위해 IMU preintegration에 대해 공부하다 보니 Lie group에 대한 깊은 이해가 필요하다는 것을 느꼈다. 3학년 1학기 때 “로봇 공학 입문” 수업을 들으며 Lie group에 대해 공부했었는데, 향후 논문 리딩에 많이 참고할 것 같아 따로 정리해 두려고 한다. 아래 등장하는 그림들은 수업 시간에 필기한 자...</p></div></div></a></div><div class="card"> <a href="/posts/SE3_group/"><div class="card-body"> <em class="timeago small" date="2022-09-19 00:00:00 +0900" >Sep 19, 2022</em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Lie group] SE(3) group 정리</h3><div class="text-muted small"><p> SO(3) group에 이어서 SE(3) group에 대해 정리해본다. 관련 포스팅 [Lie group] SO(3) group 정리 reference textbook Lynch, Kevin M., and Frank C. Park. Modern robotics. Cambridge University Press, 2017...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/GAN_mnist/" class="btn btn-outline-primary" prompt="Older"><p>[GAN] MNIST dataset을 이용한 손글씨 생성</p></a> <a href="/posts/LeGO_LOAM_review/" class="btn btn-outline-primary" prompt="Newer"><p>[LeGO-LOAM] LeGO-LOAM: Lightweight and Ground-Optimized Lidar Odometry and Mapping on Variable Terrain 논문 리뷰</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/Isornorphism">Gwanhyeong Song</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/3d-scanner/">3D scanner</a> <a class="post-tag" href="/tags/ir-light/">IR light</a> <a class="post-tag" href="/tags/solidworks/">Solidworks</a> <a class="post-tag" href="/tags/discriminator/">discriminator</a> <a class="post-tag" href="/tags/exponential/">exponential</a> <a class="post-tag" href="/tags/gan/">gan</a> <a class="post-tag" href="/tags/generative-model/">generative model</a> <a class="post-tag" href="/tags/generator/">generator</a> <a class="post-tag" href="/tags/hardware/">hardware</a> <a class="post-tag" href="/tags/levenberg/">Levenberg</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script>
